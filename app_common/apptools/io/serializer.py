""" Module with the serialization api function and supporting classes. The goal
is to store a pyface's task-based project.

The implementation relies on a recursive class which selects the serializer
needed based on the type of the object and splits the object content into a
dictionary of data and a dictionary of numpy arrays. The first data can be
dumped into a json file. The dictionary of data can be dumped into an HDF5
file.

These serializers are versioned: as soon as the content of either dictionary
gets modified for an object type, the serializer's protocol gets bumped up 1
unit and that defines the new standard. The software will (try to) guaranty
that any file can be loaded, but a project can only be written into the latest
protocol.
"""
import numpy as np
import logging
from six import string_types

from traits.api import HasStrictTraits

from app_common.traits.has_traits_utils import get_trait_type
from .serialization_utils import get_data_filename, get_ndArray_id, \
    get_object_id, get_save_timestamp, get_user

logger = logging.getLogger(__name__)

# Std attrs for all ChromatographyData to be rebuilt
TRAIT_NAMES_TO_SKIP = {'trait_added', 'trait_modified', '_unique_keys',
                       'type_id', 'unique_id'}

TRAIT_NAMES_TO_FORCE_COLLECTION = {"name"}

# Event values can't be requested, constant can't be set and properties will be
# rebuilt from other attributes.
TRAIT_TYPES_TO_SKIP = {'constant', 'event', 'property'}


class Serializer(HasStrictTraits):
    """ Base class for all serializaton classes to a dict of values and a dict
    of arrays.

    Note: serializers have a protocol_version attribute, set to 0 by default.
    Each serializer should bump its version by 1 in any PR which modifies the
    location or content of the data generated by serialization.
    That attribute should also be bump for the deserializer which deserializes
    the same object, such that the serializer and deserializer that work
    together have the same protocol version.

    FIXME: We should change the implementation to have the object being
    serialized as an attribute of the Serializer rather than being passed to
    all methods.
    """
    #: Version of the protocol.
    protocol_version = 0

    #: Class level attribute with dict mapping all ndarrays to a unique ID.
    array_collection = {}

    #: Class level attribute with dict mapping all IDs to the stored object.
    # This is needed to prevent garbage collection of the object stored, so
    # that its id (location in memory) isn't released and made available to
    # another object. That would create collisions during deserializations. The
    # reason stored objects might be get garbage collected is because they are
    # often build from models rather than being models themselves (for which
    # the application has handles on).
    instance_collection = {}

    #: Class level attribute to lookup available serializers
    serializer_map = {}

    @classmethod
    def add_array_to_collection(cls, arr_id, array):
        cls.array_collection[arr_id] = array

    def serialize(self, obj):
        """ The serialize function is the entryway into the recursive
        serialization it should only be executed by the highest level object
        being serialized.
        """
        serializer = self.select_serializer(obj)
        serial_data = serializer.get_serial_data(obj)
        return serial_data

    def get_serial_data(self, obj):
        """ The get_serial_data serializes the class structure into a
        serial_data as described in the build function.
        """
        serial_data = self.get_serial_data_base(obj)
        serial_data['data'] = self.get_data(obj)
        serial_data.update(self.get_instance_data(obj))
        return serial_data

    def get_serial_data_base(self, obj, obj_id=None):
        """ Arrays and pandas objects provide a unique uuid already computed so
        that the same ID is used in the serial data and in the array_collection
        """
        if obj_id is None:
            obj_id = get_object_id(obj)

        serial_data_base = {
            'class_metadata': {
                'type': obj.__class__.__name__,
                'version': self.protocol_version,
                'id': obj_id
            },
        }
        # Store the object so that its id doesn't get reused
        self.instance_collection[obj_id] = obj
        return serial_data_base

    def get_data(self, obj):
        """ Store as data values typically passed to constructors as positional
        arguments.
        """
        return None

    def get_instance_data(self, obj):
        """ Given an object, get_instance_data will convert the object into
        a dictionary of attributes that are required to instantiate the object
        during deserialization.
        """
        instance_data = {}
        for attr_name in self.attr_names_to_serialize(obj):
            next_object = getattr(obj, attr_name)
            try:
                instance_data[attr_name] = self.serialize(next_object)
            except ValueError as e:
                msg = "Failed to serialize the attr {} of a {}. Error was {}."
                msg = msg.format(attr_name, obj, e)
                logger.exception(msg)
                raise ValueError(msg)

        return instance_data

    def attr_names_to_serialize(self, obj):
        """ Collect all standard traits that need to be serialized.
        """
        candidates = set(obj.trait_names()) - TRAIT_NAMES_TO_SKIP
        final = set()
        for attr_name in candidates:
            if get_trait_type(obj, attr_name) not in TRAIT_TYPES_TO_SKIP:
                final.add(attr_name)
        return final

    def select_serializer(self, obj):
        """ Select the serializer class to perform the serialization.
        """
        klass = obj.__class__.__name__
        try:
            serializer = self.serializer_map[klass + '_Serializer']()
        except (KeyError, AttributeError) as e:
            msg = ("Failed to serialize {}: the {} class does not have a "
                   "Serializer. Error was {}.")
            msg = msg.format(obj, klass, e)
            logger.exception(msg)
            raise ValueError(msg)

        return serializer


class SimpleObj_Serializer(Serializer):
    """ Base Serializer for keyword arg only constructors, such as most
    HasTraits classes.
    """
    def get_serial_data(self, obj):
        serial_data = self.get_serial_data_base(obj)
        serial_data.update(self.get_instance_data(obj))
        return serial_data


class DataElement_Serializer(SimpleObj_Serializer):
    """ Base Serializer for keyword arg only constructors, such as most
        HasTraits classes.
    """
    def attr_names_to_serialize(self, obj):
        return ['name', 'uuid', 'editable']


class BasicType_Serializer(Serializer):
    """ Basic types are type that are native in both python and json.

    Includes booleans, integers, floats, long ints, numpy.float64, numpy.int64,
    string/unicode and None: for all these objects, the value itself can be
    stored in json, and deserialized by just loading the data with json.load.
    """
    def get_serial_data(self, obj):
        return self.get_data(obj)

    def get_data(self, obj):
        data = obj
        return data


class bool_Serializer(BasicType_Serializer):
    pass


class float_Serializer(BasicType_Serializer):
    pass


class float64_Serializer(BasicType_Serializer):
    pass


class int_Serializer(BasicType_Serializer):
    pass


class long_Serializer(BasicType_Serializer):
    pass


class int64_Serializer(BasicType_Serializer):
    """ Int64 element as present in Pandas indexes. """
    pass


class str_Serializer(BasicType_Serializer):
    pass


class unicode_Serializer(BasicType_Serializer):
    pass


class NoneType_Serializer(BasicType_Serializer):
    pass


class dict_Serializer(Serializer):
    def get_serial_data(self, obj):
        return self.get_data(obj)

    def get_data(self, obj):
        for key, val in obj.items():
            is_basic_type = isinstance(key, (int, float, string_types))
            if not is_basic_type:
                msg = "Unable to serialize a dict with a key of type {} " \
                      "(key={}). It requires for the serializer to serialize" \
                      " the key too, which isn't done currently."
                logger.exception(msg.format(type(key), key))
                raise NotImplementedError(msg)

        return {key: self.serialize(val) for key, val in obj.items()}


class TraitDictObject_Serializer(dict_Serializer):
    pass


class list_Serializer(Serializer):
    def get_serial_data(self, obj):
        return self.get_data(obj)

    def get_data(self, obj):
        return [self.serialize(item) for item in obj]


class TraitListObject_Serializer(list_Serializer):
    pass


class set_Serializer(Serializer):
    def get_serial_data(self, obj):
        serial_data = self.get_serial_data_base(obj)
        serial_data.update({"data": self.get_data(obj)})
        return serial_data

    def get_data(self, obj):
        return [self.serialize(item) for item in obj]


class Series_Serializer(Serializer):
    def get_instance_data(self, obj):
        instance_data = {'index': [], 'data': []}
        for key, val in obj.iteritems():
            instance_data['index'].append(self.serialize(key))
            instance_data['data'].append(self.serialize(val))
        return instance_data


class Timestamp_Serializer(Serializer):
    """ Serializer for pandas.tslib.Timestamp.
    """
    def get_data(self, obj):
        return str(obj)

    def get_instance_data(self, obj):
        """ No attrs to store. """
        return {}


class date_Serializer(Serializer):
    """ Serializer for datetime.date objects.
    """
    def get_data(self, obj):
        data = [obj.year, obj.month, obj.day]
        return data

    def get_instance_data(self, obj):
        """ No attrs to store. """
        return {}


class DataFrame_Serializer(Serializer):
    protocol_version = 1

    def get_serial_data(self, df):
        df_id = get_ndArray_id(df)
        filename = get_data_filename(df)
        serial_data = self.get_serial_data_base(df, obj_id=df_id)
        serial_data['class_metadata'].update({'filename': filename})
        self.add_array_to_collection((filename, df_id), df)
        return serial_data


class ndarray_Serializer(Serializer):
    protocol_version = 1

    def get_serial_data(self, ndArray):
        # Check if ndArray is numerical
        # FIXME pytables cannot handle Unicode arrays.  Can remove if future
        # pytables updates can handle Unicode.
        if ndArray.dtype.char == 'U':
            ndArray = np.array([s.encode('ascii') for s in ndArray])

        arr_id = get_ndArray_id(ndArray)
        filename = get_data_filename(ndArray)
        data = self.get_data(ndArray)

        serial_data = self.get_serial_data_base(ndArray, obj_id=arr_id)
        serial_data['class_metadata'].update({'filename': filename})
        self.add_array_to_collection((filename, arr_id), data)

        return serial_data

    def get_data(self, data):
        return data


class SmartUnit_Serializer(Serializer):
    def get_serial_data(self, obj):
        serial_data = self.get_serial_data_base(obj)
        serial_data.update({'data': self.get_data(obj)})
        return serial_data

    def get_data(self, obj):
        data = [obj.label, obj.value, obj.derivation, obj.offset, obj.valid]
        data = self.serialize(data)
        return data


class tuple_Serializer(Serializer):
    def get_serial_data(self, obj):
        serial_data = self.get_serial_data_base(obj)
        serial_data.update({'data': self.get_data(obj)})
        return serial_data

    def get_data(self, obj):
        # Storing values in json as a list since its a native json type.
        data = [self.serialize(item) for item in obj]
        return data


class unit_Serializer(Serializer):
    def get_data(self, obj):
        data = [obj.value, obj.derivation, obj.offset]
        data = self.serialize(data)
        return data

    def get_instance_data(self, obj):
        instance_data = {'label': obj.label}
        return instance_data


class UnitArray_Serializer(Serializer):
    """ Treat a unitArray like an array with a unit attribute.
    """
    protocol_version = 1

    def get_serial_data(self, uarray):
        # Store the array of values
        arr_id = get_ndArray_id(uarray)
        filename = get_data_filename(uarray)
        data = self.get_data(uarray)

        serial_data = self.get_serial_data_base(uarray, obj_id=arr_id)
        serial_data['class_metadata'].update({'filename': filename})
        self.add_array_to_collection((filename, arr_id), data)

        # Store the units
        serial_data.update(self.get_instance_data(uarray))
        return serial_data

    def get_data(self, obj):
        return np.array(obj)

    def get_instance_data(self, obj):
        return {"units": self.serialize(obj.units)}


class UnitScalar_Serializer(Serializer):
    def get_data(self, obj):
        data = obj.item()
        return float(data)

    def get_instance_data(self, obj):
        return {"units": self.serialize(obj.units)}


class UUID_Serializer(Serializer):
    def get_data(self, obj):
        return str(obj)

    def attr_names_to_serialize(self, obj):
        return []


def serialize(obj, array_collection=None, software_name="", software_uuid="",
              software_version=None, klass=None, additional_serializers=None,
              user_id=None):
    """ Serialization functional entry point.

    Parameters
    ----------
    obj : any
        Object to serialize

    array_collection : dict
        Dictionary mapping all numpy arrays stored to an id in the serial data.

    additional_serializers : dict, optional
        Dictionary mapping class names to the serializer class to use to
        serialize an object.

    Returns
    -------
    tuple
        2-tuple containing the serialized data dictionary and the array
        collection dict.
    """
    if klass is None:
        klass = Serializer

    if user_id is None:
        user_id = get_user()

    if additional_serializers is None:
        additional_serializers = {}

    if array_collection is None:
        array_collection = {}

    Serializer.array_collection = array_collection
    serializer_map = {}
    # Additional serializers added afterwards, to allow projects to override
    # the way to serialize basic types:
    local_serializers = {key: val for key, val in globals().items()
                         if key.endswith("_Serializer")}
    serializer_map.update(local_serializers)
    # This comes after to allow to overwrite general serializers by specific
    # implementations in addition to allowing to extend the list of objects to
    # be deserialized:
    serializer_map.update(additional_serializers)
    klass.serializer_map = serializer_map
    serializer = klass()

    class_metadata = {'type': 'SerializedData',
                      'date': get_save_timestamp(),
                      'software_name': software_name,
                      'software_uuid': software_uuid,
                      'software_version': software_version,
                      'user': user_id}

    serialized_data = {'class_metadata': class_metadata,
                       'data': serializer.serialize(obj)}

    return serialized_data, serializer.array_collection
