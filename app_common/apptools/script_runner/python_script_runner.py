""" Define a custom Python script that can be user created and exec-ed while
having access to the main Application launching the script.
"""
from os.path import basename, splitext
import logging
import sys
from six import PY2
import contextlib
from traits.api import Any, Code, Dict, File, HasStrictTraits

from app_common.std_lib.sys_utils import extract_traceback

if PY2:
    from StringIO import StringIO
else:
    from io import StringIO

logger = logging.getLogger(__name__)


class PythonScriptRunError(ValueError):
    pass


class PythonScriptRunner(HasStrictTraits):
    """ Python script capable of running custom code while having access to an
    Application object.

    The code get executed in a context which by default contains the
    application object (as ``app``), the currently active ``task`` and its
    ``study``. It also contains a ``__name__`` entry to allow the definition of
    a logger as well as both datasources as entries ``user_datasource`` and
    ``study_datasource``.

    The script can modify the objects passed or create new ones. All new
    objects created will not be accessible by the main application except if
    called ``new_task``. In that case, the corresponding objects will be
    grabbed from the modified context and opened as a new window.
    """
    #: Code to be executed (string)
    code = Code

    #: File path where the code is pulled from. It may have been changed since.
    path = File

    #: Application object within which to run the script
    app = Any

    #: Task launching the script running
    task = Any

    #: Namespace inside which to run the script
    context = Dict

    def run(self):
        """ Run the script code inside the specified context

        Returns
        -------
        str
            Content of the stdout generated by the running of the script.
        """
        try:
            msg = "Running code in script context {}".format(self.context)
            logger.debug(msg)
        except Exception as e:
            msg = "Failed to build the context: error was {}".format(e)
            logger.error(msg)
            raise ValueError(msg)

        try:
            # This code must define a new task which is the transformed version
            # of the current one.
            with temp_catch_stdout() as output_io:
                exec(self.code, self.context)
        except Exception as e:
            tb = extract_traceback()
            msg = "Failed to run script {} with error {}: '{}'. Traceback:\n{}"
            msg = msg.format(self.path, type(e), e, tb)
            logger.error(msg)
            raise PythonScriptRunError(msg)
        else:
            output = output_io.getvalue()
            return output

    def _context_default(self):
        if not self.app:
            msg = "Unable to create the context to run the script in because" \
                  " no application object was provided."
            logger.error(msg)
            raise ValueError(msg)

        script_name = basename(self.path)
        supp_context = {"app": self.app,
                        "__name__": splitext(script_name)[0]}

        # Build the context from globals and then update with above so that the
        # above is guarantied to be un-modified.
        context = globals()
        context.update(supp_context)
        return globals()

    def _path_default(self):
        logger.info("No file path was given for the script with code {}.")
        return "UNKNOWN FILE PATH"

    def _task_default(self):
        if self.app is None:
            return None
        else:
            return self.app.active_task


@contextlib.contextmanager
def temp_catch_stdout():
    """ Temporarily send all STDOUT to a stringIO.

    Used to display the output from the exec call of a python script run in the
    UI.
    """
    old = sys.stdout
    stdout = StringIO()
    sys.stdout = stdout
    yield stdout
    sys.stdout = old
